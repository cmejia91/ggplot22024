# Maps {#maps}


```{r, include = FALSE}
source("common.R")
columns(1, 2 / 3)
```

Plotting geospatial data is a common visualisation task, and one that requires specialised tools. Typically the problem can be decomposed into two problems: using one data source to draw a map, and adding metadata from another information source to the map. 

## Polygon maps 
\index{Maps!geoms} 
\index{Data!spatial}
\index{geom\_polygon}

Perhaps the simplest approach to drawing maps is to use `geom_polygon()` to draw boundaries for different regions. For this example we take data from the maps package using `ggplot2::map_data()`. The maps package isn't particularly accurate or up-to-date, but it's built into R so it's a reasonable place to start. Here is a data set specifying the county boundaries within Michigan:

```{r}
mi_counties <- map_data("county", "michigan") %>% 
  select(lon = long, lat, group, id = subregion)
head(mi_counties)
```

In this data set we have four variables: `lat` and `long` specify the latitude and longitude of a point, `id` specifies the name of a region, and `group` provides a unique identifier for a contiguous area within a region (e.g., if a region consists of multiple islands). We can construct a map using `geom_polygon()` which draws each county as a distinct polygon. By default `geom_polygon()` draws filled polygons (left), but we can override this by setting `fill = NA` (right):

`r columns(2, 2/3)`
```{r}
ggplot(mi_counties, aes(lon, lat)) +
  geom_polygon(aes(group = group)) + 
  coord_quickmap()

ggplot(mi_counties, aes(lon, lat)) +
  geom_polygon(aes(group = group), fill = NA, colour = "grey50") + 
  coord_quickmap()
```

In both plots I use `coord_quickmap()` to adjust the axes to ensure that longitude and latitude are rendered on the same scale. Chapter \@ref(coord) discusses coordinate systems in ggplot2 in more general terms, but as we'll see below, geospatial data often require a more exacting approach. For this reason, ggplot2 provides `geom_sf()` and `coord_sf()` to handle spatial data specified in simple features format.

## Simple features maps {#sf} 

There are a few limitations to the approach outlined above, not least of which is the fact that the simple "longitude-latitude" data format is not typically used in real world mapping. Vector data for maps are typically encoded using the "simple features" standard produced by the Open Geospatial Consortium. The sf package developed by Edzer Pebesma <https://github.com/r-spatial/sf> provides an excellent toolset for working with such data, and the `geom_sf()` and `coord_sf()` functions in ggplot2 are designed to work together with the sf package. 

To introduce these functions, we rely on the ozmaps package by Michael Sumner <https://github.com/mdsumner/ozmaps/> which provides maps for Australian state boundaries, local government areas, electoral boundaries, and so on. To illustrate what an sf data set looks like, we import a data set depicting the borders of Australian states and territories:

<!-- Dani... Hm. ozmaps is not on CRAN. That argues for USAboundaries, but to be honest I prefer a data set for which most readers will expect an explanation - I think using USA data is bad because American readers expect it to be common knowledge requiring no explanation, and no-one else does. May need to help Michael with https://github.com/mdsumner/ozmaps/issues/10 -->

`r columns(1, 1)`
```{r}
library(ozmaps)
library(sf)

oz_states <- ozmaps::ozmap_states
oz_states
```

The output prints out some of the metadata associated with the data set (discussed momentarily), and shows that the data set is essentially a tibble with 11 rows and 4 columns. One advantage to sf data is immediately apparent: Australia is comprised of six states, four territories and Macquarie Island, which is politically part of Tasmania. There are 11 distinct geographical units, and accordingly there are 11 rows to this data set (compare this with the mi_counties data, which comprises one row per polygon vertex).  

The key column in this data set is the `geometry` variable, which specifies the spatial geometry for each of the Australian states and territories. Each element in the `geometry` column is a multipolygon object and --- as the name suggests --- contains data specifying the vertices of one or more polygons that demark the border of a state or territory. Given data in this format, we can use `geom_sf()` and `coord_sf()` to draw a serviceable map without specifying any parameters or even explicitly declaring any aesthetics:

```{r}
ggplot(oz_states) + 
  geom_sf() + 
  coord_sf()
```

To understand why this works, note that `geom_sf()` relies on a `geometry` aesthetic that is not used elsewhere in ggplot2. This aesthetic can be specified in one of three ways. In the simplest case (illustrated above) when the user does nothing, `geom_sf()` will attempt to map it to a column named `geometry`. However, if the `data` argument is an sf object then `geom_sf()` is able to automatically detect a column that specifies a simple features geometry (discussed below), and constructs the mapping using that column regardless of what it is named. The third possibility is that the user can specify the mapping manually in the usual way with `aes(geometry = my_column)`. The `coord_sf()` function governs the map projection, discussed in Section \@ref(mapproj). 

### Layered maps

In some instances you may want to overlay one map on top of another. The ggplot2 package supports this by allowing you to add multiple `geom_sf()` layers to a plot. The code below draws a plot with two map layers: the first uses the oz_states data to fill the states in different colours, and the second uses the oz_votes data to draw the electoral boundaries:

`r columns(n = 1, aspect_ratio = 1)`
```{r}
oz_votes <- ozmaps::abs_ced

ggplot() + 
  geom_sf(
    data = oz_states, 
    mapping = aes(fill = name), 
    show.legend = FALSE
  ) +
  geom_sf(data = oz_votes, fill = NA) + 
  coord_sf()
```

It is worth noting that the first layer to this plot maps the `fill` aesthetic in onto a variable in the data. In this instance the `name` variable is a categorical variable and does not convey any additional information, but the same approach can be used to visualise other kinds of area metadata. For example, if the oz_states data had an additional column specifying the unemployment level in each state, we could map the `fill` aesthetic to that variable. 

### Labelled maps {#geom_sf_label}

Adding labels to maps is an example of annotating plots (Chapter \@ref(annotations)) and is supported by the `geom_sf_label()` and `geom_sf_text()` functions. For example, while an Australian audience might be reasonably expected to know the names of the Australian states (and are left unlabelled in the plot above) few Australians would know the names of different electorates in the Sydney metropolitan region. With this in mind, the plot below zooms in on the Sydney region by specifying `xlim` and `ylim` in `coord_sf()` and then uses `geom_sf_label()` to overlay each electorate with a label:

```{r}
ggplot(oz_votes) + 
  geom_sf() + 
  coord_sf(xlim = c(150.97, 151.3), ylim = c(-33.98, -33.79)) + 
  geom_sf_label(aes(label = NAME), label.padding = unit(1, "mm"))
```

### Adding other geoms

Though `geom_sf()` is special in some ways, it nevertheless behaves in much the same fashion as any other geom, allowing additional data to be plotted on a map using standard geoms. For example, we may wish to plot the locations of the Australian capital cities on the map using `geom_point()`. The code below illustrates how this is done:

`r columns(n = 1, aspect_ratio = 1)`
```{r}
oz_capitals <- tibble::tribble( 
  ~city,           ~lat,     ~lon, #labels are wrong!!!
  "Sydney",    151.2093, -33.8688, 
  "Melbourne", 144.9631, -37.8136,
  "Brisbane",  153.0251, -27.4698,
  "Adelaide",  138.6007, -34.9285,
  "Perth",     115.8605, -31.9505,
  "Hobart",    138.6007, -34.9285,
  "Canberra",  149.1300, -35.2809,
  "Darwin",    130.8456, -12.4634
)

ggplot() + 
  geom_sf(data = oz_votes) + 
  geom_sf(data = oz_states, colour = "black", fill = NA) + 
  geom_point(data = oz_capitals, mapping = aes(x = lat, y = lon), colour = "red") + 
  coord_sf()
```

In this example `geom_point` is used only to specify the locations of the capital cities, but the basic idea can be extended to handle point metadata more generally. For example if the oz_capitals data were to include an additional variable specifying the number of electorates within each metropolitan area, we could encode that data using the `size` aesthetic.

## Map projections {#mapproj}

At the start of the chapter I drew maps by plotting longitude and latitude on a Cartesian plane, as if geospatial data were no different to other kinds of data one might want to plot. To a first approximation this is okay, but when one becomes concerned about accuracy it no longer suffices. There are two fundamental problems with the approach.

The first issue is the shape of the planet. The Earth is neither a flat plane, nor indeed is it a perfect sphere. As a consequence, to map a co-ordinate value (longitude and latitude) to a location we need to make assumptions about all kinds of things. How ellipsoidal is the Earth? Where is the centre of the planet? Where is the origin point for longitude and latitude? Where is the sea level? How do the tectonic plates move? All these things are relevant, and depending on what assumptions one makes the same co-ordinate can be mapped to locations that are tens of meters apart. The set of assumptions about the shape of the Earth is referred to as the *geodetic datum* and while it might not matter for some data visualisations, for others it is critical. There are several different choices one might consider: if your focus is North America the "North American Datum" (NAD83) is a good choice, whereas if your perspective is global the "World Geodetic System" (WGS84) is probably better. 

The second issue is the shape of your map. The Earth is approximately ellipsoidal, but in most instances your spatial data need to be drawn on a two dimensional plane. It is not possible to map the surface ellipsoid to a plane without some distortion or cutting, and you will have to make choices about what distortions you are prepared to accept when drawing a map. This is the job of the *map projection*. 

Map projections are often classified in terms of the geometric properties that they preserve: area-preserving projections ensure that regions of equal area on the globe are drawn with equal area on the map, shape-preserving (or conformal) projections ensure that the local shape of regions is preserved, and so on. It is not possible for any projection to be shape-preserving and area-preserving. It is a little beyond the scope of this book to discuss map projections in detail (see Geocomputation with R <https://geocompr.robinlovelace.net/> by Robin Lovelace, Jakub Nowosad and Jannes Muenchow), other than to note that the simple features specification allows you to indicate which map projection you want to use.

Taken together, the geodetic datum (e.g, WGS84), the type of map projection (e.g., Mercator) and the parameters of the projection (e.g., location of the origin) specify a *coordinate reference system*, or CRS, a complete set of assumptions used to translate the latitude and longitude information into a two dimensional map. An sf object often includes a default CRS, as illustrated below:

```{r}
st_crs(oz_votes)
```

As this output illutrates, the CRS can be described in two different ways. You can either use a numeric "EPSG code" (see <http://www.epsg-registry.org/>) or you can use the "proj4string", a more verbose and (slightly) more human-readable format. In ggplot2, the CRS is controlled by `coord_sf()` to ensure that every layer in the plot uses the same projection. By default, `coord_sf()` uses the CRS associated with the geometry column of the data (or, if there are multiple data sets with a different associated CRS, the first layer in the plot to do so). Because sf data typically supply a sensible choice of CRS, this process usually unfolds invisibly, requiring no intervention from the user. However, should you need to set the CRS yourself, you can specify the `crs` parameter. Some careful thought is required to do so, however, as the plot below illustrates:

```{r}
ggplot(oz_votes) +
  geom_sf() + 
  coord_sf(crs = st_crs("+proj=lcc +datum=WGS84"))
```

In this map I have used the WGS84 datum (quite reasonably) and  conformal conic (LCC) projection, which is often used in aeronautical applications because straight lines on the map are approximate "great circles" on the globe, and it sgenerally considered a good projection for regional maps in the middle latitudes. However, the map looks terrible because I haven't set the parameters very wisely. To fix this, I centre the map at longitude 140 and latitude -25, and fix the two standard parallels (lines at which there are no distortions) at latitudes -18 and -36.

```{r}
crs <- "+proj=lcc +datum=WGS84 +lat_0=-25 +lon_0=140 +lat_1=-18 +lat_2=-36"
ggplot(oz_votes) +
  geom_sf() + 
  coord_sf(crs = st_crs(crs))
```
 


## Working with simple features data {#sfdetail}

(highlight that multipolygon is flexible enough to draw eden monaro)

```{r}
p <- ggplot(oz_votes) +   
  geom_sf(aes(fill = NAME == "Eden-Monaro"), show.legend = FALSE)

# Eden-Monaro consists of two polygons, one with hole 
p + coord_sf(xlim = c(147.75, 150.25), ylim = c(-37.5, -34.5)) 
p + coord_sf(xlim = c(150, 150.25), ylim = c(-36, -36.3)) 
```


(Dig into the structure of sf a bit... maybe take the Dawson electorate, split the multipolygon into individual polygons and colour the islands separately??? Etc.)


## Raster maps {#rastermaps}

Instead of displaying context with vector boundaries, you might want to draw a traditional map underneath. This is called a raster image. The easiest way to get a raster map of a given area is to use the ggmap package, which allows you to get data from a variety of online mapping sources including OpenStreetMap and Google Maps. Downloading the raster data is often time consuming so it's a good idea to cache it in a rds file, as illustrated here: \index{ggmap} \index{Raster data}


<!-- TODO: Note that OSM is temporarily(??) not supported -->
<!-- works because we have the cached mi_raster.rds file -->
<!-- see: https://github.com/dkahle/ggmap/issues/117 -->

```{r}
if (file.exists("mi_raster.rds")) {
  mi_raster <- readRDS("mi_raster.rds")
} else {
  bbox <- c(
    min(mi_counties$lon), min(mi_counties$lat),
    max(mi_counties$lon), max(mi_counties$lat)
  )
  mi_raster <- ggmap::get_openstreetmap(bbox, scale = 8735660)
  saveRDS(mi_raster, "mi_raster.rds")
}
```

Note that finding the appropriate `scale` in this example required a lot of manual tweaking, so it may take some effort to obtain the data you want. Once you have the raster data, the `ggmap()` function from the ggmap package allows you to create a plot drawing the map, as illustrated in the left panel below:

```{r}
ggmap::ggmap(mi_raster)

mi_cities <- tbl_df(maps::us.cities) %>%
  filter(country.etc == "MI") %>%
  select(-country.etc, lon = long) 

ggmap::ggmap(mi_raster) +
  geom_point(aes(size = pop), mi_cities, colour = "red") +
  scale_size_area()
```

The nice thing about the `ggmap()` function is that the output is a ggplot object, so adding metadata to the plot is accomplished in the same way one would add layers to any other plot. This is illustrated in the right side plot above.



<!-- If you have raster data from the raster package, you can convert it to the form needed by ggplot2 with the following code: -->

<!-- ```{r, eval = FALSE} -->
<!-- df <- as.data.frame(raster::rasterToPoints(x)) -->
<!-- names(df) <- c("lon", "lat", "x") -->

<!-- ggplot(df, aes(lon, lat)) + -->
<!--   geom_raster(aes(fill = x)) -->
<!-- ``` -->





## Data sources

* The USAboundaries package, <https://github.com/ropensci/USAboundaries> contains state, county and zip code data for the US. As well as current boundaries, it also has state and county boundaries going back to the 1600s.

* The tigris package, <https://github.com/walkerke/tigris>, makes it easy to access the US Census TIGRIS shapefiles. It contains state, county, zipcode, and census tract boundaries, as well as many other useful datasets.

* The rnaturalearth package bundles up the free, high-quality data from <http://naturalearthdata.com/>. It contains country borders, and borders for the top-level region within each country (e.g. states in the USA, regions in France, counties in the UK).

* The osmar package, <https://cran.r-project.org/package=osmar> wraps up the OpenStreetMap API so you can access a wide range of vector data including individual streets and buildings
  
* If you have your own shape files (`.shp`) you can load them into R with `sf::read_sf()`


