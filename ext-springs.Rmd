```{r setup, include = FALSE}
source("common.R")
library(grid)
set.seed(12L)
columns(1, 1 / 1.61, 1)
```

# A case study {#spring1}

Chapter \@ref(extensions) provided a high-level overview showing you how to create ggplot2 extensions, building on the discussion of ggplot2 internals in Chapter \@ref(internals). In this chapter we'll take that knowledge a step further, providing a deeper dive into the process of developing full-featured extensions. To do this, we'll take a single example -- building a new geom that looks like a spring -- and follow it all the way through the development process.

This is a carefully crafted example. You're unlikely to actually want to use springs to visualise your data, which is the reason why ggplot2 doesn't already provide a geom for this. However, springs are just complicated enough to illustrate the most important parts of the process, making them ideal for our purposes! 

We'll develop the extension in five phases:

1.  We'll start as simple as possible by using the existing `geom_path()`, pairing it with a new stat (Section \@ref(spring-stat)).
2.  The new stat only allows fixed diameter and tension, so we'll next allow these to be used as aesthetics (Section \@ref(spring2)).
3.  A stat is a great place to start but has some fundamental restrictions so we'll convert our work so far in to a proper geom (Section \@ref(spring3)).
4.  Geoms can only use dimensions relative to the data, and can't use absolute sizes like 2cm, so next we'll show you how to draw the spring with grid (Section \@ref(spring4)).
5.  We'll finish up by providing a custom scale and legend to pair with the geom (Section \@ref(spring5)).

Once you've worked your way through this chapter, we highly recommend browsing the ggplot2 source code to look at how other stats and geoms are implemented.
They will often be more complicated than what you need, but they'll give you a sense of the things you can do.

## What is a spring? {#intuitive-spring}

Developing an extension usually starts with an idea of what you want to draw. In this case, we want to draw a spring between two points, so we need some code that will draw a plausible-looking spring! There are probably many ways to do this, but one simple approach is to draw a circle while moving the "pen" in one direction. Here's a data set that defines a circle using 100 points:

```{r}
circle <- tibble(
  radians = seq(0, 2 * pi, length.out = 100),
  x = cos(radians),
  y = sin(radians),
  index = 1:100,
  type = "circle"
)

ggplot(circle, aes(x = x, y = y, alpha = -index)) + 
  geom_path(show.legend = FALSE) + 
  coord_equal()
```

To transform this circle into a spring that stretches along the x axis using dplyr, we might do something like this:

```{r}
spring <- circle %>% 
  mutate(
    motion = seq(0, 1, length.out = 100),
    x = x + motion,
    type = "spring"
  )

ggplot(spring, aes(x = x, y = y, alpha = -index)) + 
  geom_path(show.legend = FALSE) + 
  coord_equal()
```

In this case our "spring" has only looped around once -- and doesn't look much like an actual spring -- but if we were to continue tracing the circle while moving along the x axis we'd end up with a spring with multiple loops. The faster we move the "pen", the more we will stretch the spring. This gives us some insight into the two parameters that characterise our springs:

-   The `diameter` of the spring, defined by the size of the circle.
-   The `tension` of the spring, defined by how fast we move along x.

Although we can be pretty sure this is not a physically correct parameterisation of springs in the real world, it will be good enough for our purposes. 

Now that we have a method for drawing springs, it's worth spending a little time thinking about what a geom based on this method will require. The code we've written up to this point is perfectly fine for a single plot, but when creating an extension there are new questions to consider. How will we specify the diameter of a spring? How do we keep the circles circular even as we change the aspect ratio of the plot? Can we map diameter and tension to variables in the data? Should they be scaled aesthetics, or are they always parameters that must be the same for all springs in a layer? If we plan to distribute our spring geom to other R users, is it a good idea for our geom to depend on the dplyr package?

## Part 1: A stat {#spring-stat}

Let's start turning this idea into a ggplot2 extension. Because we're creating an extension that draws a new ggplot2 layer, we need to decide whether the ggproto object we create should be a `Stat` or a `Geom`. Perhaps surprisingly, this decision isn't guided by whether we want to end up with `geom_spring()` or `stat_spring()`: there are a lot of `Stat` extensions that are used via a `geom_*()` constructor. A better way to think about this decision is to think carefully about what your code is doing: if what you're doing is drawing transformed data using pre-existing geom, then you can use a `Stat`. This is often a good strategy: unlike `Geom` objects, a `Stat` is simply a data-transformation pipeline, and that's usually simpler to code. 

The code we wrote in the last section fits this description nicely. All we're doing is drawing a path, but we're circling around instead of going in a straight line. That suggests we can use a `Stat` that transforms the data and then uses `GeomPath` to take care of the actual drawing. So we'll attempt this first.

### Building functionality

Whenever you are developing a new `Stat` a sensible strategy is to begin by writing the data transformation function. Later on you can incorporate this function into the ggproto `Stat` object itself, but it makes your life easier if you write this function as a separate exercise. In this case, we're going to need a `create_spring()` function that takes a start point, an end point, a diameter, and a tension. More precisely:

- Our start point will be defined by arguments `x` and `y`.
- Our end point will be defined by arguments `xend` and `yend`. 
- The `diameter` argument will be used to scale the size of our circle. 
- Defining `tension` is slightly trickier. The quantity we actually want to express is "how far the spring moves relative to the size of the circles". So we'll define `tension` to refer to the total distance moved from the start point to the end point, divided by the size of the circles.^[If you have a background in statistics, you'll recognise this as roughly analogous to how a z-statistic is calculated.]
- We'll also have a parameter `n` to give the number of points used per revolution, defining the visual fidelity of the spring. 

We can now write code for our `create_spring()` function:

```{r}
create_spring <- function(x, 
                          y, 
                          xend, 
                          yend, 
                          diameter = 1, 
                          tension = 0.75, 
                          n = 50) {
  
  # Validate the input arguments
  if (tension <= 0) {
    rlang::abort("`tension` must be larger than zero.")
  }
  if (diameter == 0) {
    rlang::abort("`diameter` can not be zero.")
  }
  if (n == 0) {
    rlang::abort("`n` must be greater than zero.")
  }
  
  # Calculate the direct length of the spring path
  length <- sqrt((x - xend)^2 + (y - yend)^2)
  
  # Calculate the number of revolutions and points we need
  n_revolutions <- length / (diameter * tension)
  n_points <- n * n_revolutions
  
  # Calculate the sequence of radians and the x and y offset values
  radians <- seq(0, n_revolutions * 2 * pi, length.out = n_points)
  x <- seq(x, xend, length.out = n_points)
  y <- seq(y, yend, length.out = n_points)
  
  # Create and return the transformed data frame
  data.frame(
    x = cos(radians) * diameter/2 + x,
    y = sin(radians) * diameter/2 + y
  )
}
```

This function preserves the logic of the spring code we wrote in Section \@ref(intuitive-spring), but it does a few new things that matter a lot when writing extensions:

- It is precise in specifying the parameters that define the spring.
- It explicitly checks the input, and uses `rlang::abort()` to throw an error if the user passes an invalid value to the function.
- It uses base R functions to do the work: there is no dplyr code in this function because we don't want our `Stat` to depend on dplyr.^[If you have experience developing packages you might wonder about the choice to use `rlang::abort()` rather than using the base `stop()` function. We could certainly have chosen to use the base R function here, but since ggplot2 itself uses the rlang package it makes very little difference in this case.]

One nice thing about writing `create_spring()` as a function is that we can test it out^[If we were planning to bundle this code as an R package, we could expand on this and write formal unit tests for `create_spring()` using the testthat package.] to convince ourselves that the logic works:

```{r}
spring <- create_spring(
  x = 4, y = 2, xend = 10, yend = 6,
  diameter = 2, tension = 0.6, n = 50
)

ggplot(spring) + 
  geom_path(aes(x = x, y = y)) + 
  coord_equal()
```

### Creating the stat

Now that we know what we want to do with the user input, our next task is to encapsulate this functionality in a `Stat`. To do this, we'll take what we learned about creating `Stat` objects in Section \@ref(new-stats) and extend it a little. Our first step is to write some code that creates a subclass of `Stat` that we'll call `StatSpring`:

```{r, eval = FALSE}
StatSpring <- ggproto("StatSpring", Stat)
```

This creates a new `Stat`^[You can also choose to extend an existing `Stat` class, but that is relatively uncommon.] subclass named `StatSpring`. This class doesn't do anything interesting at this point: the only thing this code does so far is give the class a name.^[By convention ggproto classes always use CamelCase for naming, and the new class is always saved into a variable with the same name.] To make this useful, we'll need to specify the methods that will build in the functionality we desire. In Section \@ref(new-stats) we created a `Stat` by overriding the default method `compute_group()` and the default field for `required_aes`,^[As we mentioned earlier, ggproto doesn't make a strong distinction between methods and fields. `Stat` objects expect `compute_group()` to be a function, so we refer to `compute_group()` as a method because that is the standard terminology in object oriented programming. In contrast, `Stat` expects `required_aes` to be a variable, so we call it a field.] but `Stat` objects have many properties you can modify. If we print the `Stat` object, we can see a list of those properties:

```{r}
Stat
```

You can modify almost any of these: the only ones that you shouldn't touch are `aesthetics` and `parameters`, which are intended for internal use only. 

For our `StatSpring` example, the three methods/fields that we'll need to specify are `setup_data()`, `compute_panel()`, and `required_aes`. We'll go through this in more detail in the next section, but to help you see what we're aiming for, the complete code for our stat is shown below:

```{r}
StatSpring <- ggproto("StatSpring", Stat, 
  
  # Edit the input data to ensure the group identifiers are unique
  setup_data = function(data, params) {
    if (anyDuplicated(data$group)) {
      data$group <- paste(data$group, seq_len(nrow(data)), sep = "-")
    }
    data
  },
  
  # Construct data for this panel by calling create_spring()
  compute_panel = function(data, 
                           scales, 
                           diameter = 1, 
                           tension = 0.75, 
                           n = 50) {
    cols_to_keep <- setdiff(names(data), c("x", "y", "xend", "yend"))
    springs <- lapply(
      seq_len(nrow(data)), 
      function(i) {
        spring_path <- create_spring(
          data$x[i], 
          data$y[i], 
          data$xend[i], 
          data$yend[i], 
          diameter = diameter, 
          tension = tension, 
          n = n
        )
        cbind(spring_path, unclass(data[i, cols_to_keep]))
      }
    )
    do.call(rbind, springs)
  },
  
  # Specify which aesthetics are required input
  required_aes = c("x", "y", "xend", "yend")
)
```

We can print any of these methods with a command such as `StatSpring$compute_panel` or `StatSpring$setup_data`.


### Methods

Let's take a closer look at the methods defined for our `StatSpring`. As discussed in Section \@ref(new-stats) the most important methods for a stat are the three `compute_*` methods. One of these must always be defined, usually `compute_group()` or `compute_panel()`. As a rule of thumb, if the stat operates on multiple rows we start by implementing a `compute_group()` method, and if the stat operates on single rows we implement a `compute_panel()` method. Our spring stat is the latter kind: each spring is defined by a single row of the original data, so we'll use the `compute_panel()` method which receives all the data for a single panel.

As you can see by looking at source code for our `compute_panel()` method, we're doing a bit more than simply calling our `create_spring()` function:

```{r, results='hide'}
function(data, scales, diameter = 1, tension = 0.75, n = 50) {
    cols_to_keep <- setdiff(names(data), c("x", "y", "xend", "yend"))
    springs <- lapply(
      seq_len(nrow(data)), 
      function(i) {
        spring_path <- create_spring(
          data$x[i], 
          data$y[i], 
          data$xend[i], 
          data$yend[i], 
          diameter = diameter, 
          tension = tension, 
          n = n
        )
        cbind(spring_path, unclass(data[i, cols_to_keep]))
      }
    )
    do.call(rbind, springs)
  }
```

We use `lapply()` to loop over each row of the data and create the points required to draw the corresponding spring. For each such spring, we use `cbind()` to combine the spring data with all the non-position columns of the input row. This is very important, since otherwise the aesthetic mappings to e.g. color and size would be lost. Finally, because the output of `lapply()` is a list of data frames (one per spring), we use `rbind()` to combine these into a single data frame that gets returned.

When defining a new stat, it is very common to specify one or both of the `setup_data()` and `setup_params()` methods. These methods are called at the very beginning of the plot building process, so you can use them to do early checks and modifications of the parameters and data.

For our `StatSpring` example, we use the `setup_data()` method to ensure that each input row has a unique group aesthetic. This is important because we're going to draw our springs with `GeomPath`, and we need to make sure that the data frame output by the stat has a unique identifier for each spring. Doing so ensures that the geom draws each spring as a distinct path, and won't draw any connecting lines between different springs. Again, there are some subtle details to call attention to in the implementation:

```{r, results='hide'}
function(data, params) {
  if (anyDuplicated(data$group)) {
    data$group <- paste(data$group, seq_len(nrow(data)), sep = "-")
  }
  data
}
```

Notice that this implementation preserves the original value of `data$group`, appending a unique id if needed. This is important because the group aesthetic is sometimes used to carry metadata, and we don't want to lose that information.

The final part of our new class is the `required_aes` field. This is a character vector that gives the names of aesthetics that the user *must* provide to the stat. In this case, we need to make sure the user specifies four position aesthetics: x and y define where the spring starts, while xend and yend define where it ends. The `required_aes` field, along with `default_aes` and `non_missing_aes`, also defines the aesthetics that this stat understands. Any aesthetics that don't appear in these fields (or in the fields of the corresponding geom) will generate a warning and the mapping will be ignored.

### Constructors

Now that we have our `StatSpring` ggproto object, it's time to write constructor functions that the user will interact with. Strictly speaking we don't need to do this, because `geom_path(stat = "spring")` will already work, but it's good practice to write constructor functions for the convenience of your users. In addition, the constructor function provides a good place to document the new functionality. 


Perhaps surprisingly, stat objects are almost always paired with a `geom_*()` constructor because most ggplot2 users are accustomed to adding geoms, not stats, when building up a plot. The constructor itself is mostly boilerplate code that wraps a call to `layer()`; just take care to match the argument order and naming used in the ggplot2's constructors so you don't surprise your users.

```{r}
geom_spring <- function(mapping = NULL,
                        data = NULL, 
                        stat = "spring",
                        position = "identity", 
                        ..., 
                        diameter = 1, 
                        tension = 0.75,
                        n = 50, 
                        arrow = NULL, 
                        lineend = "butt", 
                        linejoin = "round",
                        na.rm = FALSE, 
                        show.legend = NA, 
                        inherit.aes = TRUE
                        ) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomPath,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      diameter = diameter,
      tension = tension,
      n = n,
      arrow = arrow,
      lineend = lineend,
      linejoin = linejoin,
      na.rm = na.rm,
      ...
    )
  )
}
```

For the sake of completeness you should also create a `stat_*()` constructor function. There are no surprises here: `stat_spring()` is very similar to `geom_spring()` except that it provides a default geom instead of a default stat.

```{r}
stat_spring <- function(mapping = NULL, 
                        data = NULL, 
                        geom = "path", 
                        position = "identity", 
                        ..., 
                        diameter = 1, 
                        tension = 0.75, 
                        n = 50, 
                        na.rm = FALSE, 
                        show.legend = NA, 
                        inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = StatSpring, 
    geom = geom, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      diameter = diameter, 
      tension = tension, 
      n = n, 
      na.rm = na.rm, 
      ...
    )
  )
}
```


### Testing the stat

Now that everything is in place, we can test out our new layer:

```{r}
df <- tibble(
  x = runif(5, max = 10),
  y = runif(5, max = 10),
  xend = runif(5, max = 10),
  yend = runif(5, max = 10),
  class = sample(letters[1:2], 5, replace = TRUE)
)

ggplot(df) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend)) +
  coord_equal()
```

This looks pretty good. Users can call our `geom_spring()` constructor function and get sensible results. Better yet, because we've written a new stat, we get a number of features for free, like scaling and faceting:

```{r}
ggplot(some_data) + 
  geom_spring(
    aes(x, y, xend = xend, yend = yend, colour = class),
    linewidth = 1
  ) +
  coord_equal() + 
  facet_wrap(~ class)
```

Users also have the option of calling the `stat_spring()` constructor, which can be helpful if for some reason they want to draw the springs with points rather than paths:

```{r}
ggplot(some_data) + 
  stat_spring(
    aes(x, y, xend = xend, yend = yend, colour = class),
    geom = "point", 
    n = 15
  ) +
  coord_equal() + 
  facet_wrap(~ class)
```

### Post-mortem

We have now successfully created our first extension. It works, but it has some limitations that we now need to think about. 

One shortcoming of our implementation is that diameter and tension are constants that can only be set for the full layer. These settings feel more like aesthetics and it would be nice if their values could be mapped to a variable in the data. We'll discuss solutions to this problem in Sections \@ref(spring2) and \@ref(spring3).

Another, potentially bigger, issue is that the spring path is defined relative to the coordinate system of the plot. This means that strong deviations from an aspect ratio of 1 will visibly distort the spring, as you can see in the example below:

```{r}
ggplot() + 
  geom_spring(aes(x = 0, y = 0, xend = 3, yend = 20))
```

The same underlying problem means that the diameter of the spring is expressed in coordinate space, meaning that it is difficult to define a meaningful default:

```{r}
ggplot() + 
  geom_spring(aes(x = 0, y = 0, xend = 100, yend = 80))
```

We'll ignore this issue for the moment, and address it in Section \@ref(spring4).

## Part 2: Adding aesthetics {#spring2}

The stat we created in the last section treats the `diameter` and `tension` as constant arguments: they're not aesthetics and the user can't map them onto a variable in the data. We can fix this by making a few small changes to the `StatSpring` code:

```{r}
StatSpring <- ggproto("StatSpring", Stat,
                      
  setup_data = function(data, params) {
    if (anyDuplicated(data$group)) {
      data$group <- paste(data$group, seq_len(nrow(data)), sep = "-")
    }
    data
  },
  
  compute_panel = function(data, scales, n = 50) {
    cols_to_keep <- setdiff(names(data), c("x", "y", "xend", "yend"))
    springs <- lapply(seq_len(nrow(data)), function(i) {
      spring_path <- create_spring(
        data$x[i], 
        data$y[i], 
        data$xend[i], 
        data$yend[i], 
        data$diameter[i],
        data$tension[i], 
        n
      )
      cbind(spring_path, unclass(data[i, cols_to_keep]))
    })
    do.call(rbind, springs)
  },
  
  required_aes = c("x", "y", "xend", "yend"),
  optional_aes = c("diameter", "tension")
)
```

The main difference with our previous attempt is that the `diameter` and `tension` arguments to `compute_panel()` have gone away, and they're now taken from the data (just like `x`, `y`, etc).
This has a downside that we'll fix in Section \@ref(spring3): we can no longer set fixed aesthetics. Because of this, we'll need to remove those arguments from the constructor function:

```{r}
geom_spring <- function(mapping = NULL, 
                        data = NULL, 
                        stat = "spring", 
                        position = "identity", 
                        ..., 
                        n = 50, 
                        arrow = NULL, 
                        lineend = "butt", 
                        linejoin = "round", 
                        na.rm = FALSE,
                        show.legend = NA, 
                        inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = stat, 
    geom = GeomPath, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      n = n, 
      arrow = arrow, 
      lineend = lineend, 
      linejoin = linejoin, 
      na.rm = na.rm, 
      ...
    )
  )
}
```

The `stat_spring()` constructor would require the same kind of change.

All that is left is to test our new implementation out:

```{r}
df <- tibble(
  x = runif(5, max = 10),
  y = runif(5, max = 10),
  xend = runif(5, max = 10),
  yend = runif(5, max = 10),
  class = sample(letters[1:2], 5, replace = TRUE),
  tension = runif(5),
  diameter = runif(5, 0.5, 1.5)
)

ggplot(df, aes(x, y, xend = xend, yend = yend)) + 
  geom_spring(aes(tension = tension, diameter = diameter))
```

It appears to work. However, as we expected, it's no longer possible to set `diameter` and `tension` as parameters:

```{r}
ggplot(df, aes(x, y, xend = xend, yend = yend)) + 
  geom_spring(diameter = 0.5)
```

### Post-mortem

In this section we further developed our spring stat so that `diameter` and `tension` can be used as aesthetics, varying across springs.
Unfortunately, there's a major downside: these features no longer can be set globally.
We're still also missing a way to control the scaling of the two aesthetics.
Fixing both these problems requires the same next step: move our implementation away from `Stat` and towards a proper `Geom`.

## Part 3: A geom {#spring3}

In many cases a Stat-centred approach is sufficient, for example, many of the graphic primitives provided by the [ggforce](https://ggforce.data-imaginist.com) package are Stats.
But we need to go further with the spring geom because the `tension` and `diameter` aesthetics need to be specified in units that are unrelated to the coordinate system.
Consequently, we'll rewrite our geom to be a proper `Geom` extension.

### Geom extensions

As discussed in Chapter \@ref(extensions), there are many similarities between `Stat` and `Geom` extensions. The biggest difference is that `Stat` extensions return a modified version of the input data, whereas `Geom` extensions return graphical objects. In some cases creating a new geom requires you to use the grid package (we'll cover this in Section \@ref(spring4)), but often you don't have to. 

Much like stat objects, geom objects in ggproto have several methods and fields you can modify. You can see the list by printing the object:

```{r}
Geom
```

### Creating the geom

In much the same way that a stat uses the `compute_layer()`, `compute_panel()`, and `compute_group()` methods to transform the data, a geom uses `draw_layer()`, `draw_panel()`, and `draw_group()` to create graphical representations of the data. In the same way that we created `StatSpring` by writing a `compute_panel()` method to do the heavy lifting, we'll create `GeomSpring` by writing a `draw_panel()` method:

```{r}
GeomSpring <- ggproto("GeomSpring", Geom,
  
  # Ensure that each row has a unique group id
  setup_data = function(data, params) {
    if (is.null(data$group)) {
      data$group <- seq_len(nrow(data))
    }
    if (anyDuplicated(data$group)) {
      data$group <- paste(data$group, seq_len(nrow(data)), sep = "-")
    }
    data
  },
  
  # Transform the data inside the draw_panel() method
  draw_panel = function(data, 
                        panel_params, 
                        coord, 
                        n = 50, 
                        arrow = NULL,
                        lineend = "butt", 
                        linejoin = "round", 
                        linemitre = 10,
                        na.rm = FALSE) {
    
    # Transform the input data to specify the spring paths
    cols_to_keep <- setdiff(names(data), c("x", "y", "xend", "yend"))
    springs <- lapply(seq_len(nrow(data)), function(i) {
      spring_path <- create_spring(
        data$x[i], 
        data$y[i], 
        data$xend[i], 
        data$yend[i], 
        data$diameter[i],
        data$tension[i], 
        n
      )
      cbind(spring_path, unclass(data[i, cols_to_keep]))
    })
    springs <- do.call(rbind, springs)
    
    # Use the draw_panel() method from GeomPath to do the drawing
    GeomPath$draw_panel(
      data = springs, 
      panel_params = panel_params, 
      coord = coord, 
      arrow = arrow, 
      lineend = lineend, 
      linejoin = linejoin, 
      linemitre = linemitre, 
      na.rm = na.rm
    )
  },
  
  # Specify the default and required aesthetics
  required_aes = c("x", "y", "xend", "yend"),
  default_aes = aes(
    colour = "black", 
    linewidth = 0.5, 
    linetype = 1L, 
    alpha = NA, 
    diameter = 1, 
    tension = 0.75
  )
)
```

Despite the length of this code, most of it is familiar:

- The `setup_data()` methods are essentially the same: in both cases they ensure that every row in the input data has a unique group identifier.

- The `draw_panel()` method for our `GeomSpring` object is very similar to the `compute_panel()` method. The main difference is that our `draw_panel()` method has an extra step: it passes the computed spring coordinates to `GeomPath$draw_panel()`. Because springs are just fancy paths, the `GeomPath$draw_panel()` method works perfectly well here. 

- Unlike the `StatSpring` code that we wrote earlier, the `GeomSpring` code uses the `default_aes` field to provide default values for any aesthetic that the user does not specify.

One aspect to this code may surprise developers who are used to object-oriented design from other languages. Calling the method of a kindred object directly, as we do when invoking `GeomPath$draw_panel()` from within `GeomSpring$draw_panel()`, is not considered good practice in other object-oriented systems. However, because ggproto objects are stateless (Section \@ref(ggproto-style)), this is exactly as safe as subclassing `GeomPath` and calling the parent method. You can see this approach all over the place in the ggplot2 source code.


### Constructor

As with our earlier attempts the final step is to write a constructor function `geom_spring()`. The code is not much different to earlier versions: we use `GeomSpring` instead of `GeomPath`, and we use the identity stat instead of `StatSpring`.

```{r}
geom_spring <- function(mapping = NULL, 
                        data = NULL, 
                        stat = "identity", 
                        position = "identity", 
                        ..., 
                        n = 50, 
                        arrow = NULL, 
                        lineend = "butt", 
                        linejoin = "round", 
                        na.rm = FALSE,
                        show.legend = NA, 
                        inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = stat, 
    geom = GeomSpring, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      n = n, 
      arrow = arrow, 
      lineend = lineend, 
      linejoin = linejoin, 
      na.rm = na.rm, 
      ...
    )
  )
}
```

### Testing the geom

We now have a proper geom with working default aesthetics and the ability to setting aesthetics as parameters:


```{r}
ggplot(df, aes(x, y, xend = xend, yend = yend)) + 
  geom_spring(aes(tension = tension, diameter = diameter))
ggplot(df, aes(x, y, xend = xend, yend = yend)) + 
  geom_spring(diameter = 0.5)
```

It does have some limitations still, because the units for `diameter` and `tension` are expressed relative to the scale of the raw data. The actual diameter of a spring with `diameter = 0.5` will be different depending on the axis limits, and if the x and y axes are not on the same scale the shape of the spring will be distorted. However, this is about as far as we can get without learning about grid. 



### Post-mortem

In this section we finally created our own `Geom` extension. This is often the natural conclusion to the development of new layer, but not always. Sometimes you'll find that the `Stat` approach works perfectly well for your purposes, and it has the advantage that you can use the stat with multiple geoms. The final choice is up to you as the developer, and should be guided by how you expect people to use the layer.

Perhaps surprisingly, we haven't talked about what goes on inside the `draw_*()` methods yet. Our `GeomSpring` object relies on the `draw_panel()` method from `GeomPath` to do the work of creating the graphical output. This is quite common. For example, even the relatively complex [`GeomBoxplot`](https://github.com/tidyverse/ggplot2/blob/master/R/geom-boxplot.r) just uses the draw methods from `GeomPoint()`, `GeomSegment` and `GeomCrossbar`. 

If you need to go deeper, you'll need to learn a little about grid. Creating grid grobs is an advanced technique, needed by relatively few geoms. But creating a grid grob gives you the power to use absolute units (e.g. 1cm) and to adjust the display of the geom based on the size of the output device. We'll turn to that next.

## An introduction to grid

The grid package provides the underlying graphics system upon which ggplot2 is built. It's one of two quite different drawing systems that are included in base R: base graphics and grid. Base graphics has an imperative "pen-on-paper" model: every function immediately draws something on the graphics device. Much like ggplot2 itself, grid takes a more declarative approach where you build up a description of the graphic as an object, which is later rendered. This declarative approach allows us to create objects that exists independently of the graphic device and can be passed around, analysed, and modified. Importantly, parts of a graphical object can refer to other parts, which allows you to do things like define this rectangle to have width equal to the length of that string of text, and so on. 

As a ggplot2 developer you will find that you can achieve a lot without ever needing to interact with grid directly, but there are situations where it is impossible to achieve what you want without going down to the grid level. The two most common situations are:

1.  You need to create graphical objects that are positioned correctly on the coordinate system, but where some part of their appearance has a fixed absolute size.
    In our case this would be the spring correctly going between two points in the plot, but the diameter being defined in cm instead of relative to the coordinate system.

2.  You need graphical objects that are updated during resizing.
    This could e.g. be the position of labels such as in the ggrepel package or the `geom_mark_*()` geoms in ggforce.

A comprehensive introduction to grid is far more than we can cover in this book, but to help you get started we'll give you the absolute minimum vocabulary to understand how ggplot2 uses grid. We'll introduce core concepts like grobs, viewports, graphical parameters, and units but if you want to go deeper, we highly recommend *R Graphics* by @murrell:2011.

### Grobs

To understand how grid works, the first thing we need to talk about are grobs. 
Grobs (**gr**aphic **ob**jects) are the atomic representations of graphical elements in grid, and include types like points, lines, circles, rectangles, and text. The grid package provides functions like `pointsGrob()`, `linesGrob()`, `circleGrob()`, `rectGrob()`, and `textGrob()` that create graphical objects without drawing anything to the graphics device. These functions are vectorised, allowing a single point grob to represent multiple points, for instance:

```{r}
library(grid)
circles <- circleGrob(
  x = c(0.1, 0.4, 0.7), 
  y = c(0.5, 0.3, 0.6),
  r = c(0.1, 0.2, 0.3)
)
```

Notice that this does not create any output. Much like a ggplot2 plot object, this grob is a declarative description of a set of circles. To trigger a drawing operation we first call `grid.newpage()` to clear the current graphics device, and then `grid.draw()` to perform a draw operation:

```{r}
grid.newpage()
grid.draw(circles)
```

In addition to providing geometric primitives, grid also allows you to construct composite objects that combine multiple grobs using `grobTree()`. Here's an illustration:

```{r}
labels <- textGrob(
  label = c("small", "medium", "large"),
  x = c(0.1, 0.4, 0.7), 
  y = c(0.5, 0.3, 0.6),
)

composite <- grobTree(circles, labels)
grid.newpage()
grid.draw(composite)
```

It is also possible to define your own grob classes. You can define a new primitive grob class using `grob()` or a new composite class using `gTree()`, and specify special behaviour for your new class. We'll see an example of this in a moment. 

### Viewports

The second key concept in grid is the idea of a viewport. A viewport is a rectangular plotting region that supplies its own coordinate system for grobs that are drawn within it, and can also provide a tabular grid in which other viewports an be nested. An individual grob can have its own viewport or, if none is provided, it will inherit one. While we won't need to consider viewports when building the grob for our springs, they're an important concept that powers much of the high-level layout of ggplot2 graphics so we'll very briefly introduce them here. In the example below we use `viewport()` to define two different viewports, one with default parameters, and second one that is rotated around the midpoint by 15 degrees:

```{r}
vp_default <- viewport()
vp_rotated <- viewport(angle = 15)
```

This time around, when we create our composite grobs, we'll explicitly assign them to specific viewports by setting the `vp` argument:

```{r}
composite_default <- grobTree(circles, labels, vp = vp_default)
composite_rotated <- grobTree(circles, labels, vp = vp_rotated)
```

When we plot these two grobs, we can see the effect of the viewport: although `composite_default` and `composite_rotated` are comprised of the same two primitive grobs (i.e., `circles` and `labels`), they belong to different viewports so they look different when the plot is drawn:

```{r}
grid.newpage()
grid.draw(composite_default)
grid.draw(composite_rotated)
```

### Graphical parameters

The next concept we need to understand is the idea of graphical parameters. When we defined the `circles` and `labels` grobs, we only specified some of its properties. For example, we said nothing about colour or transparency, and so these properties are all set to their default values. The `gpar()` function in grid allows you to specify graphical parameters as distinct objects:

```{r}
gp_blue <- gpar(col = "blue", alpha = 0.5)
gp_orange <- gpar(col = "orange", alpha = 0.5)
```

The `gp_blue` and `gp_orange` objects provide lists of graphical settings that can now be applied to any grob we like using the `gp` argument:

```{r}
grob1 <- grobTree(circles, labels, vp = vp_default, gp = gp_blue)
grob2 <- grobTree(circles, labels, vp = vp_rotated, gp = gp_orange)
```

When we plot these two grobs, they inherit the settings provided by the graphical parameters as well as the viewports to which they are assigned:

```{r}
grid.newpage()
grid.draw(grob1)
grid.draw(grob2)
```


### Units

The last core concept that we need to discuss is the grid unit system. The grid package allows you to specify the positions (e.g. `x` and `y`) and dimensions (e.g. `length` and `width)` of grobs and viewports using a flexible language. In the grid unit system there are three qualitatively different styles of unit:

-   Absolute units (e.g. centimeters, inches, and points refer to physical sizes).
-   Relative units (e.g. npc which scales the viewport size between 0 and 1).
-   Units based on other grobs (e.g. grobwidth).

The `unit()` function is the main function we use when specifying units: `unit(1, "cm")` refers to a length of 1 centimeter, whereas `unit(0.5, "npc")` refers to a length half the size of the relevant viewport. The unit system supports arithmetic operations that are only resolved at draw time, which makes it possible to combine different types of units: `unit(0.5, "npc") + unit(1, "cm")` defines a point one centimeter to the right of the center of the current viewport.

### Building grob classes

Now that we have a basic understanding of grid, let's attempt to create our own "surprise" grob class: objects that are circles if they are smaller than 3cm, but transform into squares whenever they are larger than 3cm. This is not the most useful kind of graphical object, but it's useful for illustrating the flexibility of the grid system. The first step is to write our own constructor function using `grob()` or `gTree()`, depending on whether we are creating a primitive or composite object. We begin by creating a "thin" constructor function:

```{r}
surpriseGrob <- function(x, 
                         y, 
                         size, 
                         default.units = "npc", 
                         name = NULL, 
                         gp = gpar(), 
                         vp = NULL) {
  
  # Ensure that input arguments are units
  if (!is.unit(x)) x <- unit(x, default.units)
  if (!is.unit(y)) y <- unit(y, default.units)
  if (!is.unit(size)) size <- unit(size, default.units)
  
  # Construct the surprise grob subclass as a gTree
  gTree(
    x = x, 
    y = y, 
    size = size, 
    name = name, 
    gp = gp, 
    vp = vp, 
    cl = "surprise"
  )
}
```

This function doesn't do very much. All it does is ensure that the `x`, `y`, and `size` arguments are grid units, and sets the class name to be "surprise". To define the behaviour of our grob, we need to specify methods for one or both of the generic functions `makeContext()` and `makeContent()`:

-   `makeContext()` is called when the parent grob is rendered and allows you to control the viewport of the grob. We won't need to use that for our surprise grob.

-   `makeContent()` is called every time the drawing region is resized and allows you to customise the look of the grob based on the size or other aspect.

Because these generic functions use the S3 object oriented programming system, we can define our method simply by appending the class name to the end of the function name. That is, the `makeContent()` method for our surprise grob is defined by creating a function called `makeContent.surprise()` that takes a grob as input and returns a modified grob as output:

```{r}
makeContent.surprise <- function(x) {
  x_pos <- x$x
  y_pos <- x$y
  size <- convertWidth(x$size, unitTo = "cm", valueOnly = TRUE)
  
  # Figure out if the given sizes are bigger or smaller than 3 cm
  circles <- size < 3
  
  # Create a circle grob for the small ones
  if (any(circles)) {
    circle_grob <- circleGrob(
      x = x_pos[circles], 
      y = y_pos[circles], 
      r = unit(size[circles] / 2, "cm")
    )
  } else {
    circle_grob <- nullGrob()
  }
  
  # Create a rect grob for the large ones
  if (any(!circles)) {
    square_grob <- rectGrob(
      x = x_pos[!circles], 
      y = y_pos[!circles], 
      width = unit(size[!circles], "cm"),
      height = unit(size[!circles], "cm")
    )
  } else {
    square_grob <- nullGrob()
  }
  
  # Add the circle and rect grob as children of our input grob
  setChildren(x, gList(circle_grob, square_grob))
}
```

Some of the functions we've called here are new, but they all reuse the core concepts that we discussed earlier. Specifically:

- `convertWidth()` is used to convert grid units from one type to another.
- `nullGrob()` creates a blank grob.
- `gList()` creates a list of grobs.
- `setChildren()` specifies the grobs that belong to a gTree composite grob. 

The effect of this function is to ensure that every time the grob is rendered the absolute size of each shape is recalculated. All shapes smaller than 3cm become circles, and all shapes larger than 3cm become squares. To see how this plays out, lets call our new function:

```{r}
surprises <- surpriseGrob(
  x = c(0.25, 0.45, 0.75), 
  y = c(0.5, 0.5, 0.5), 
  size = c(0.05, 0.15, 0.25)
)
```

The `surprises` grob contains three shapes whose locations and sizes have been specified relative to the size of the viewport. At this point in time we have no idea which of these shapes will be circles and which will be squares: that depends in on the absolute size of the viewport in which the `surprises` grob is to be drawn. We can now draw the grob in the usual way:

```{r}
grid.newpage()
grid.draw(surprises)
```

If you run the code above interactively and resize the plotting window you'll see that the three objects will change shape based on the size of the plotting window. It's not the most useful way to employ grid, of course, but hopefully you can see how this technique can be used to do real work.

## Part 4: A grid grob {#spring4}

Let's return to the problem at hand. Armed with our new knowledge of the grid system, we can now see how we might construct a spring grob that has an absolute diameter.

### The springGrob

If we wait with the expansion to the spring path until the `makeContent()` function, and calculate it based on coordinates in absolute units we can make sure that the diameter stays constant during resizing of the plot.
With that in mind, we can create our constructor.
We model the arguments after `segmentsGrob()` since we are basically creating modified segments:

```{r}
springGrob <- function(x0 = unit(0, "npc"), 
                       y0 = unit(0, "npc"), 
                       x1 = unit(1, "npc"), 
                       y1 = unit(1, "npc"), 
                       diameter = unit(0.1, "npc"), 
                       tension = 0.75,
                       n = 50, 
                       default.units = "npc", 
                       name = NULL, 
                       gp = gpar(), 
                       vp = NULL) {
  
  # Use the default unit if the user does not specify one
  if (!is.unit(x0)) x0 <- unit(x0, default.units)
  if (!is.unit(x1)) x1 <- unit(x1, default.units)
  if (!is.unit(y0)) y0 <- unit(y0, default.units)
  if (!is.unit(y1)) y1 <- unit(y1, default.units)
  if (!is.unit(diameter)) diameter <- unit(diameter, default.units)
  
  # Return a gTree of class "spring"
  gTree(x0 = x0, y0 = y0, x1 = x1, y1 = y1, diameter = diameter, 
       tension = tension, n = n, name = name, gp = gp, vp = vp, 
       cl = "spring")
}
```

We see that once again our constructor is a very thin wrapper around the `gTree()` constructor, simply ensuring that arguments are converted to units if they are not already.

We now need to create the `makeContent()` method that creates the actual spring coordinates.

```{r}
makeContent.spring <- function(x) {
  x0 <- convertX(x$x0, "mm", valueOnly = TRUE)
  x1 <- convertX(x$x1, "mm", valueOnly = TRUE)
  y0 <- convertY(x$y0, "mm", valueOnly = TRUE)
  y1 <- convertY(x$y1, "mm", valueOnly = TRUE)
  diameter <- convertWidth(x$diameter, "mm", valueOnly = TRUE)
  tension <- x$tension
  n <- x$n
  springs <- lapply(seq_along(x0), function(i) {
    cbind(
      create_spring(x0[i], y0[i], x1[i], y1[i], diameter[i], tension[i], n),
      id = i
    )
  })
  springs <- do.call(rbind, springs)
  spring_paths <- polylineGrob(springs$x, springs$y, springs$id, 
                               default.units = "mm", gp = x$gp)
  setChildren(x, gList(spring_paths))
}
```

There is not anything fancy going on here.
We grabs the coordinates and diameter settings from the gTree and converts them all to millimeters.
As we now have everything in absolute units we calculate the spring paths using our trusted `create_spring()` function and puts the returned coordinates in a polyline grob.

Before we use this in a geom let us test it out:

```{r}
springs <- springGrob(
  x0 = c(0, 0),
  y0 = c(0, 0.5),
  x1 = c(1, 1),
  y1 = c(1, 0.5),
  diameter = unit(c(1, 3), "cm"),
  tension = c(0.2, 0.7)
)
grid.newpage()
grid.draw(springs)
```

It appears to work and we can now design our new (and final) geom.

### The last GeomSpring

```{r}
GeomSpring <- ggproto("GeomSpring", Geom,
  setup_params = function(data, params) {
    if (is.null(params$n)) {
      params$n <- 50
    } else if (params$n <= 0) {
      rlang::abort("Springs must be defined with `n` greater than 0")
    }
    params
  },
  draw_panel = function(data, 
                        panel_params, 
                        coord, 
                        n = 50, 
                        lineend = "butt", 
                        na.rm = FALSE) {
    data <- remove_missing(data, na.rm = na.rm,
      c("x", "y", "xend", "yend", "linetype", "linewidth"),
      name = "geom_spring")
    if (is.null(data) || nrow(data) == 0) return(zeroGrob())
    if (!coord$is_linear()) {
      rlang::warn("spring geom only works correctly on linear coordinate systems")
    }
    coord <- coord$transform(data, panel_params)
    return(springGrob(coord$x, coord$y, coord$xend, coord$yend,
      default.units = "native", diameter = unit(coord$diameter, "cm"),
      tension = coord$tension, n = n,
      gp = gpar(
        col = alpha(coord$colour, coord$alpha),
        lwd = coord$linewidth * .pt,
        lty = coord$linetype,
        lineend = lineend
      )
    ))
  },
  required_aes = c("x", "y", "xend", "yend"),
  default_aes = aes(
    colour = "black", 
    linewidth = 0.5, 
    linetype = 1L, 
    alpha = NA, 
    diameter = 0.35, 
    tension = 0.75
  )
)
geom_spring <- function(mapping = NULL, 
                        data = NULL, 
                        stat = "identity", 
                        position = "identity", 
                        ..., 
                        n = 50, 
                        lineend = "butt", 
                        na.rm = FALSE, 
                        show.legend = NA, 
                        inherit.aes = TRUE) {
  layer(
    data = data, 
    mapping = mapping, 
    stat = stat, 
    geom = GeomSpring, 
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes, 
    params = list(
      n = n, 
      lineend = lineend, 
      na.rm = na.rm, 
      ...
    )
  )
}
```

The main differences from our last `GeomSpring` implementation is that we no longer care about a `group` column because each spring is defined in one line, and then of course the `draw_panel()` method.
Since we are no longer passing on the call to another geoms' `draw_panel()` method we have additional obligations in that call.
If the coordinate system is non-linear (e.g. `coord_polar()`) we emit a warning because our spring will not be adapted to that coordinate system.
We then use the coordinate system to rescale our positional aesthetics with the `transform()` method.
This will remap all positional aesthetics to lie between 0 and 1, with 0 being the lowest value visible in our viewport (scale expansions included) and 1 being the highest.
With this remapping the coordinates are ready to be passed into a grob as `"npc"` units.
By definition we understand the provided diameter as being given in centimeters.
With all the values properly converted we call the `springGrob()` constructor and return the resulting grob.
One thing we haven't touched upon is the `gpar()` call inside the `springGrob()` construction.
grid operates with a short list of very well-defined visual characteristics for grobs that are given by the `gp` argument in the constructor.
This takes a `gpar` object that holds information such as colour of the stroke and fill, linetype, font, size, etc.
Not all grobs care about all entries in `gpar()` and since we are constructing a line we only care about the gpar entries that the pathGrob understands, namely: `col` (stroke colour), `lwd` (line width), `lty` (line type), `lineend` (the terminator shape of the line).

```{r}
ggplot(df) + 
  geom_spring(aes(
    x = x, 
    y = y, 
    xend = xend, 
    yend = yend, 
    diameter = diameter, 
    tension = tension
  ))
```

As can be seen in the example above we now have springs that do not shear with the aspect ratio of the plot and thus look to conform at every angle and aspect ratio.
Further, resizing the plot will result in recalculations of the correct path so that it will continue to look as it should.

### Post-Mortem

We have finally arrived at the spring geom we set out to make.
The diameter of the spring behaves in the same way as a line width in that it remains fixed when resizing and/or changing the aspect ratio of the plot.
There are still improvements we could (and perhaps, should) do to our geom.
Most notably our `create_spring()` function remains un-vectorised and needs to be called for each spring separately.
Correctly vectorizing this function will allow for considerable speed-up when rendering many springs (if that was ever a need).
We will leave this as an exercise for the reader.

While the geom is now done, we still have a little work to do.
We need to create a diameter scale and provide legend keys that can correctly communicate diameter and tension.
This will be the topic of the final section.

## Part 5: Scales {#spring5}

Now that we have our final geom, there's still a bit of work to do before we are done.
This is because we have defined a couple of new aesthetics in the process and we would like users to be able to scale them.
There's nothing wrong with defining new aesthetics without providing a scale --- that simply means that the mapped values are passed through unchanged --- but if we want users to have some control as well as the possibility of a legend we will need to provide scales for the aesthetics.
This will be the goal of this final section.

### Scaling

Thankfully, compared to grid, creating new scales is not a huge undertaking.
It basically surmounts to creating a function with the correct name that outputs a `Scale` object.
In the code below you can see how this is done for the `tension` aesthetic:

```{r}
scale_tension_continuous <- function(..., range = c(0.1, 1)) {
  continuous_scale(
    aesthetics = "tension", 
    scale_name = "tension_c", 
    palette = scales::rescale_pal(range), 
    ...
  )
}
```

Most scale functions are simply wrappers around calls to one of the scale constructors (`continuous_scale()`, `discrete_scale()`, and `binned_scale()`).
Most importantly it names the aesthetic(s) this scale relates to and provides a palette function which transforms the input domain to the output range.
All the remaining well-known arguments from scale functions such as `name`, `breaks`, `limits`, etc. are carried through with the `...`.
For cases such as these where only a single scale is relevant for an aesthetic you'll often create a short-named version as well.
We'll also add a discrete scale to catch if this aesthetic is erroneously being used with discrete data:

```{r}
scale_tension <- scale_tension_continuous

scale_tension_discrete <- function(...) {
  rlang::abort("Tension cannot be used with discrete data")
}
```

The reason why we need `scale_tension_continuous()` when we also have `scale_tension()` is that the default scale for aesthetics is looked up by searching for a function called `scale_<aesthetic-name>_<data-type>`.

While we are at it we'll create a scale for the diameter as well:

```{r}
scale_diameter_continuous <- function(..., range = c(0.25, 0.7), unit = "cm") {
  range <- grid::convertWidth(unit(range, unit), "cm", valueOnly = TRUE)
  continuous_scale(
    aesthetics = "diameter", 
    scale_name = "diameter_c", 
    palette = scales::rescale_pal(range), 
    ...
  )
}
scale_diameter <- scale_diameter_continuous
scale_tension_discrete <- function(...) {
  rlang::abort("Diameter cannot be used with discrete data")
}
```

The only change we made from the `tension` scales is that we allow the user to define which unit the diameter range should be measured in.
Since the geom expects centimeters we will convert the range to that before passing it into the scale constructor.
In that way the user is free to use whatever absolute unit feels natural to them.

With our scales defined let us have a look:

```{r}
ggplot(df) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, tension = tension, 
                  diameter = diameter)) + 
  scale_tension(range = c(0.1, 5)) 
```

The code above shows us that both the default scale (we didn't add an explicit scale for diameter) and the custom scales (`scale_tension()`) work.
It also tells us that our job is not done, because the legend is pretty uninformative.
That is because our geom uses the default legend key constructor which is `draw_key_point()`.
This key constructor doesn't know what to do about our new aesthetics and ignores it completely.

### draw_key_spring

The key constructors are pretty simple constructors that take a data.frame of aesthetic values and uses that to draw a given representation.
If we look at the point key constructor we see that it simply constructs a pointsGrob:

```{r}
draw_key_point
```

`data` is a data.frame with a single row giving the aesthetic values to use for the key, `params` are the geom params for the layer, and `size` is the size of the key area in centimeters.

To create one that matches well with our new geom we should simply try to create a key that uses our springGrob instead:

```{r}
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}

draw_key_spring <- function(data, params, size) {
  springGrob(
    x0 = 0, y0 = 0, x1 = 1, y1 = 1,
    diameter = unit(data$diameter, "cm"), 
    tension = data$tension,
    gp = gpar(
      col = alpha(data$colour %||% "black", data$alpha),
      lwd = (data$size %||% 0.5) * .pt,
      lty = data$linetype %||% 1
    ),
    vp = viewport(clip = "on")
  )
} 
```

We add a little flourish here that is not necessary for the point key constructor, which is that we define a clipping viewport for our grob.
This means that the spring will not spill-out into the neighboring keys.

Along with that we will also have to modify our Geom to use this key constructor instead (We know we said the last version was final).
We don't have to define our Geom from scratch again, though but simply change the `draw_key()` method of our existing Geom:

```{r}
GeomSpring$draw_key <- draw_key_spring
```

With that final change our legend is beginning to make sense:

```{r}
ggplot(df) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, tension = tension, 
                  diameter = diameter)) + 
  scale_tension(range = c(0.1, 5))
```

The default key size is a bit cramped for our key, but that has to be modified by the user (ggplot2 doesn't know about the `diameter` aesthetic and cannot scale the key size to that in the same way as it does with the `size` aesthetic).

```{r}
ggplot(df) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, tension = tension, 
                  diameter = diameter)) + 
  scale_tension(range = c(0.1, 5)) +
  theme(legend.key.size = unit(1, "cm"))
```

The new legend key will be used for all scaled aesthetics, not just our new `diameter` and `tension` meaning that the key will always match the style of the layer:

```{r}
ggplot(df) + 
  geom_spring(aes(x = x, y = y, xend = xend, yend = yend, colour = class)) + 
  theme(legend.key.size = unit(1, "cm"))
```

### Post-mortem

This concludes our, admittedly a bit far-fetched, case study on how to create a spring geom.
Hopefully it has become clear that there are many different ways to achieve the same geom extension and where you end up is largely guided by your needs and how much energy you want to put into it.
While extending layers (and scales) are only a single (but important) part of the ggplot2 extension system, we will not discuss how to create other types of extensions such as coord and facet extensions.
The curious reader is invited to study the source code of both ggplot2's own Facet and Coord classes as well as the extensions available in e.g. the ggforce package.
